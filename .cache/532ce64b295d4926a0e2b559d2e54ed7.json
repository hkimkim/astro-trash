{"dependencies":[],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* jshint -W097 */\n\nclass MiniSignalBinding {\n\n  /**\n  * MiniSignalBinding constructor.\n  * @constructs MiniSignalBinding\n  * @param {Function} fn Event handler to be called.\n  * @param {Boolean} [once=false] Should this listener be removed after dispatch\n  * @param {Mixed} [thisArg] The context of the callback function.\n  * @api private\n  */\n  constructor(fn, once = false, thisArg) {\n    this._fn = fn;\n    this._once = once;\n    this._thisArg = thisArg;\n    this._next = this._prev = this._owner = null;\n  }\n\n  detach() {\n    if (this._owner === null) return false;\n    this._owner.detach(this);\n    return true;\n  }\n\n}\n\nexports.MiniSignalBinding = MiniSignalBinding; /**\n                                               * @private\n                                               */\n\nfunction _addMiniSignalBinding(self, node) {\n  if (!self._head) {\n    self._head = node;\n    self._tail = node;\n  } else {\n    self._tail._next = node;\n    node._prev = self._tail;\n    self._tail = node;\n  }\n\n  node._owner = self;\n\n  return node;\n}\n\nclass MiniSignal {\n\n  /**\n  * MiniSignal constructor.\n  * @constructs MiniSignal\n  * @api public\n  *\n  * @example\n  * let mySignal = new MiniSignal();\n  * let binding = mySignal.add(onSignal);\n  * mySignal.dispatch('foo', 'bar');\n  * mySignal.detach(binding);\n  */\n  constructor() {\n    this._head = this._tail = undefined;\n  }\n\n  /**\n  * Return an array of attached MiniSignalBinding.\n  *\n  * @param {Boolean} [exists=false] We only need to know if there are handlers.\n  * @returns {MiniSignalBinding[]|Boolean} Array of attached MiniSignalBinding or Boolean if called with exists = true\n  * @api public\n  */\n  handlers(exists = false) {\n    let node = this._head;\n\n    if (exists) return !!node;\n\n    const ee = [];\n\n    while (node) {\n      ee.push(node);\n      node = node._next;\n    }\n\n    return ee;\n  }\n\n  /**\n  * Return true if node is a MiniSignalBinding attached to this MiniSignal\n  *\n  * @param {MiniSignalBinding} node Node to check.\n  * @returns {Boolean} True if node is attache to mini-signal\n  * @api public\n  */\n  has(node) {\n    if (!(node instanceof MiniSignalBinding)) {\n      throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.');\n    }\n\n    return node._owner === this;\n  }\n\n  /**\n  * Dispaches a signal to all registered listeners.\n  *\n  * @returns {Boolean} Indication if we've emitted an event.\n  * @api public\n  */\n  dispatch() {\n    let node = this._head;\n\n    if (!node) return false;\n\n    while (node) {\n      if (node._once) this.detach(node);\n      node._fn.apply(node._thisArg, arguments);\n      node = node._next;\n    }\n\n    return true;\n  }\n\n  /**\n  * Register a new listener.\n  *\n  * @param {Function} fn Callback function.\n  * @param {Mixed} [thisArg] The context of the callback function.\n  * @returns {MiniSignalBinding} The MiniSignalBinding node that was added.\n  * @api public\n  */\n  add(fn, thisArg = null) {\n    if (typeof fn !== 'function') {\n      throw new Error('MiniSignal#add(): First arg must be a Function.');\n    }\n    return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));\n  }\n\n  /**\n  * Register a new listener that will be executed only once.\n  *\n  * @param {Function} fn Callback function.\n  * @param {Mixed} [thisArg] The context of the callback function.\n  * @returns {MiniSignalBinding} The MiniSignalBinding node that was added.\n  * @api public\n  */\n  once(fn, thisArg = null) {\n    if (typeof fn !== 'function') {\n      throw new Error('MiniSignal#once(): First arg must be a Function.');\n    }\n    return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));\n  }\n\n  /**\n  * Remove binding object.\n  *\n  * @param {MiniSignalBinding} node The binding node that will be removed.\n  * @returns {MiniSignal} The instance on which this method was called.\n  * @api public */\n  detach(node) {\n    if (!(node instanceof MiniSignalBinding)) {\n      throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.');\n    }\n    if (node._owner !== this) return this; // todo: or error?\n\n    if (node._prev) node._prev._next = node._next;\n    if (node._next) node._next._prev = node._prev;\n\n    if (node === this._head) {\n      // first node\n      this._head = node._next;\n      if (node._next === null) {\n        this._tail = null;\n      }\n    } else if (node === this._tail) {\n      // last node\n      this._tail = node._prev;\n      this._tail._next = null;\n    }\n\n    node._owner = null;\n    return this;\n  }\n\n  /**\n  * Detach all listeners.\n  *\n  * @returns {MiniSignal} The instance on which this method was called.\n  * @api public\n  */\n  detachAll() {\n    let node = this._head;\n    if (!node) return this;\n\n    this._head = this._tail = null;\n\n    while (node) {\n      node._owner = null;\n      node = node._next;\n    }\n    return this;\n  }\n}\n\nexports.MiniSignal = MiniSignal;\nexports.default = MiniSignal;"},"hash":"823babb174369f4973806eda44c88c34"}